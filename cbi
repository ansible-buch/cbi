#!/usr/bin/env python3
import os
import sys
import subprocess
import glob
import re
import getpass
import yaml
from enum import Enum

try:
    from icecream import ic
except ModuleNotFoundError as e:
    def ic(arg):
        print(arg)

from argparse import ArgumentParser
from enum import Enum

progname = os.path.basename(sys.argv[0])
version  = "0.21"


opts   = {}
stash  = {}
config = {}

class Engine(Enum):
    DOCKER = 1
    K3S    = 2


###########
def main():
###########
    global opts
    global stash
    global config
    
    get_options()

    if not os.path.exists('.cbiroot'):
        sys.exit("Must be called in the cbi root directory - exiting.")

    stash['cbiroot']    = os.getcwd()
    stash['root_env']   = os.path.join(stash['cbiroot'], 'env.yml')
    stash['roles_path'] = os.path.join(stash['cbiroot'], 'lib')

    
    if opts['which'] == 'config':
        create_sample_config()

    try:
        yamlfile = open(stash['root_env'], "r")

    except FileNotFoundError:
        sys.exit("No config file found. Exiting.")
    else:
        with yamlfile:
            config = yaml.load(yamlfile, Loader=yaml.FullLoader)

        
    if opts['which'] == 'setup':
        setup_environment(opts['server_type'])


    if opts['which'] == 'up':
        go(target="up")

    if opts['which'] == 'down':
        go(target="down")



##################
def get_options():
##################
    global opts

    parser = ArgumentParser()

    subparsers = parser.add_subparsers(dest='which')

    # config subcommand
    parser_config = subparsers.add_parser('config', help='create sample config')
    parser_config.add_argument('-f', '--force', action='store_true',
                               dest='force', help='overwrite existing config')


    # setup subcommand
    parser_setup = subparsers.add_parser('setup',
                                         help='setup container platform')
    parser_setup.add_argument("server_type",
                              choices=['docker', 'k3s'])

    
    # up subcommand
    parser_up = subparsers.add_parser('up', help='create and start app')
    parser_up.add_argument('app_path', help='path to app')
    parser_up.add_argument('--pre', action='store_true', dest='pre',
                           help='perform pre tasks and generate files')
    parser_up.add_argument('--main', action='store_true', dest='main',
                           help='perform up tasks')
    parser_up.add_argument('--wait', action='store_true', dest='wait',
                           help='perform wait tasks')
    parser_up.add_argument('--post', action='store_true', dest='post',
                           help='perform post tasks')

    # down subcommand
    parser_down = subparsers.add_parser('down', help='stop and remove app')
    parser_down.add_argument('app_path', help='path to app')
    parser_down.add_argument('--pre', action='store_true', dest='pre',
                           help='perform pre tasks')
    parser_down.add_argument('--main', action='store_true', dest='main',
                           help='perform down tasks')
    parser_down.add_argument('--wait', action='store_true', dest='wait',
                           help='perform wait tasks')
    parser_down.add_argument('--post', action='store_true', dest='post',
                           help='perform post tasks')
    parser_down.add_argument('--volumes', action='store_true', dest='volumes',
                             help='remove all volumes/PVs. '
                             'CURRENTY THE DEFAULT ACTION!')

    
    args = parser.parse_args()
    opts = vars(args)



###############
def go(target):
###############

    global stash


    os.chdir(opts['app_path'])
    stash['app_path'] = os.getcwd()


    todo = {
        'pre':  True,
        'main': True,
        'wait': True,
        'post': True,
    }

    if opts['pre']:
        todo['main'] = False
        todo['wait'] = False
        todo['post'] = False
    if opts['main']:
        todo['pre']  = False
        todo['wait'] = False
        todo['post'] = False
    if opts['wait']:
        todo['pre']  = False
        todo['main'] = False
        todo['post'] = False
    if opts['post']:
        todo['pre']  = False
        todo['main'] = False
        todo['wait'] = False
    

    pre_files  = []
    main_files = []
    wait_files = []
    post_files = []

    if target == "up":
        selector = 'U'
    elif target == "down":
        selector = 'D' 
    else:
        system.exit(f"Bad target: {target}")


    if todo['pre']:
        pre_files = sorted(glob.glob(f'tasks/{selector}[0-9][0-9]pre*'))
    if todo['main']:
        main_files = sorted(glob.glob(f'tasks/{selector}[0-9][0-9]main*'))
    if todo['wait']:
        wait_files = sorted(glob.glob(f'tasks/{selector}[0-9][0-9]wait*'))
    if todo['post']:    
        post_files = sorted(glob.glob(f'tasks/{selector}[0-9][0-9]post*'))


    # ic(pre_files)
    # ic(main_files)
    # ic(wait_files)
    # ic(post_files)
    # exit()

    if todo['pre']:
        for file in pre_files:
            ansible_runner(action='run_tasks', arg=file)
            
        if os.path.isdir('templates'):
            ansible_runner(action='generate_files')

            
    if todo['main']:
        if (engine_type() == Engine.DOCKER
            and
            os.path.exists('docker-compose.yml')):
            p = subprocess.run(['docker', 'compose', 'up', '-d'])
        
        for file in main_files:
            ansible_runner(action='run_tasks', arg=file)


    if todo['wait']:
        for file in wait_files:
            ansible_runner(action='run_tasks', arg=file)

            
    if todo['post']:
        for file in post_files:
            ansible_runner(action='run_tasks', arg=file)
            
        



            
##########################################
def ansible_runner(action=None, arg=None):
##########################################
    global stash
    global config

    cmd = [
        "ansible",
        "-i", "localhost,",
        "localhost",
        "-c", "local",
        "-m", "include_role",
        "-a", f"name=cbi tasks_from={action}.yml",
        "-e", f"root_env={stash['root_env']}",
        "-e", f"app_path={stash['app_path']}"
    ]

    if action == 'run_tasks':
        cmd += ["-e", f"task_file={arg}"]
                
    p = subprocess.run(
        cmd,
        env=dict(
            os.environ.copy(),
            ANSIBLE_ROLES_PATH=stash['roles_path'],
            ANSIBLE_DISPLAY_SKIPPED_HOSTS='false',
            ANSIBLE_LOAD_CALLBACK_PLUGINS='true',
            ANSIBLE_STDOUT_CALLBACK='yaml'
        )
    )


    
###########################
def create_sample_config():
###########################
    global opts
    
    if os.path.exists('env.yml') and not opts['force']:
        sys.exit("env.yml already exists; use --force to overwrite.")


    
    text = """
# The default domain under which apps will be accessible:
domain: example.org

# # # The default FQDN under which apps will be accessible.
# # # In most cases you should use this global setting, and only change
# # # it in individual applications if necessary:
# # #app_fqdn: ${COMPOSE_PROJECT_NAME}.{{domain}}

# Default initial password for apps (if needed):
default_password: secret

# Default salt for password hashes (we need at least 22 chars):
default_salt:     really.salty.salt.0123456789


# Name of the internal Docker network for proxy communication (Docker only):
docker_internal_network: traefik


# Where do we get certificates from (Docker only)?
# - letsencrypt: Let's Encrypt (only suitable for internet servers)
# - private_ca:  private CA
cert_resolver_type: 

# Mail address to which the CA can send notifications when certificate
# expiration is too near (if you don't need this, just leave it out):
#cert_resolver_email: webmaster@{{domain}}


# LDAP: Do you plan to deploy an OpenLDAP container (Docker only)?
# Then Traefik will open port 127.0.0.1:636 to make the LDAP service
# accessible from our host.
ldap_open_host_port: false

# LDAP directory tree root
# (of course you can ignore this if you don't use LDAP):
ldap_root: dc=example,dc=org

# Are LDAP-Accounts visible from the host (e.g. for SSH-Login)?
# (of course you can ignore this if you don't use LDAP):
ldap_host_uses_ldap: false

# The versions of all apps to be used:
# - stable: Well-tested versions as of September 2024
# - latest: Use the latest bleeding edge version whenever possible
version_style: stable

# Define some versions:
versions:
  k3s:
    stable: v1.31.0+k3s1
    latest: ""
  gitea:
    stable: 1.22.2
    latest: ""
"""
    with open('env.yml', 'w') as f:
        f.write(text)
        
    sys.exit(0)



##################
def engine_type():
##################

    try:
        p = subprocess.run(["k3s",  "--version"], capture_output=True)
        if p.returncode == 0:
            return Engine.K3S
    except:
        pass

    try:
        p = subprocess.run(["docker",  "--version"], capture_output=True)
        if p.returncode == 0:
            return Engine.DOCKER
    except:
        pass

    sys.exit("[FAIL] Neither Docker nor K3s seems to be installed.")
    


#######################
def is_executable(cmd):
#######################
    try:
        p = subprocess.run(cmd, shell=True, stderr = subprocess.DEVNULL)
        return p.returncode == 0
    except:
        return False
        

    
###################################
def setup_environment(server_type):
###################################
    global config

    def log(cmd):
        print(f"[EXEC] {cmd}")

    
    if server_type == 'docker':
        print("Sorry, this setup is not capable to perform a Docker installation.")
        print("We recommend to use <https://github.com/ansible-buch/docker-installer>.")
        sys.exit(0)



        
    # Setup K3s (the only possible alternative):
    env = os.environ.copy()

    version_style = config['version_style']
    env['INSTALL_K3S_VERSION'] = config['versions']['k3s'][version_style]
    

    if not is_executable("k3s --version"):
        cmd = "curl -fsSL https://get.k3s.io | sh -"
        log(cmd)
        p = subprocess.run(cmd, shell=True, env=env)

        # Uninstall:
        # k3s-uninstall.sh
        # rm -rf /var/lib/rancher /etc/rancher ~/.kube/*


    if not is_executable("helm version"):
        cmd = "curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash"
        log(cmd)
        p = subprocess.run(cmd, shell=True)


    cmd = "mkdir -p /etc/bash_completion.d"
    log(cmd)
    p = subprocess.run(cmd, shell=True)

    
    cmd = "kubectl completion bash >/etc/bash_completion.d/kubectl"
    log(cmd)
    p = subprocess.run(cmd, shell=True)

    
    cmd = "mkdir -p -m 0700 ~/.kube"
    log(cmd)
    p = subprocess.run(cmd, shell=True)

    cmd = "cp /etc/rancher/k3s/k3s.yaml ~/.kube/config"
    log(cmd)
    p = subprocess.run(cmd, shell=True)



if __name__ == '__main__':
    main()
